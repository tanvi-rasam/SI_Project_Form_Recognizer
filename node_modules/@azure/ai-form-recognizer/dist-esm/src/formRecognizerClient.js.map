{"version":3,"file":"formRecognizerClient.js","sourceRoot":"","sources":["../../src/formRecognizerClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  createPipelineFromOptions,\n  InternalPipelineOptions,\n  isTokenCredential,\n  bearerTokenAuthenticationPolicy,\n  operationOptionsToRequestOptionsBase,\n  AbortSignalLike\n} from \"@azure/core-http\";\nimport { TokenCredential } from \"@azure/identity\";\nimport { KeyCredential } from \"@azure/core-auth\";\nimport {\n  SDK_VERSION,\n  DEFAULT_COGNITIVE_SCOPE,\n  FormRecognizerLoggingAllowedHeaderNames,\n  FormRecognizerLoggingAllowedQueryParameters\n} from \"./constants\";\nimport { logger } from \"./logger\";\nimport { createSpan } from \"./tracing\";\nimport {\n  FormContentType,\n  FormRecognizerClientOptions,\n  FormRecognizerOperationOptions,\n  toRequestBody,\n  getContentType\n} from \"./common\";\nimport { CanonicalCode } from \"@opentelemetry/api\";\n\nimport { GeneratedClient } from \"./generated/generatedClient\";\nimport {\n  GeneratedClientAnalyzeWithCustomModelResponse as AnalyzeWithCustomModelResponseModel,\n  GeneratedClientAnalyzeLayoutAsyncResponse as AnalyzeLayoutAsyncResponseModel,\n  GeneratedClientAnalyzeReceiptAsyncResponse as AnalyzeReceiptAsyncResponseModel,\n  SourcePath,\n  OperationStatus\n} from \"./generated/models\";\nimport { PollOperationState, PollerLike } from \"@azure/core-lro\";\nimport {\n  RecognizeContentPollerClient,\n  BeginRecognizeContentPoller\n} from \"./lro/analyze/contentPoller\";\nimport {\n  RecognizeCustomFormPollerClient,\n  BeginRecognizeCustomFormPoller\n} from \"./lro/analyze/customFormPoller\";\nimport {\n  RecognizeReceiptPollerClient,\n  BeginRecognizeReceiptPoller\n} from \"./lro/analyze/receiptPoller\";\nimport { FormRecognizerRequestBody, RecognizedFormArray, FormPageArray } from \"./models\";\nimport { RecognizeContentResultResponse, RecognizeFormResultResponse } from \"./internalModels\";\nimport {\n  toRecognizeFormResultResponse,\n  toRecognizeContentResultResponse,\n  toRecognizeFormResultResponseFromReceipt\n} from \"./transforms\";\nimport { createFormRecognizerAzureKeyCredentialPolicy } from \"./azureKeyCredentialPolicy\";\n\n/**\n * Options for content/layout recognition.\n */\nexport type RecognizeContentOptions = FormRecognizerOperationOptions;\n\n/**\n * The state of a recognize content operation\n */\nexport type RecognizeContentOperationState = PollOperationState<FormPageArray> & {\n  /**\n   * A string representing the current status of the operation.\n   */\n  status: OperationStatus;\n};\n\n/**\n * Options for the start content/layout recognition operation\n */\nexport type BeginRecognizeContentOptions = RecognizeContentOptions & {\n  /**\n   * Delay to wait until next poll, in milliseconds\n   */\n  updateIntervalInMs?: number;\n  /**\n   * Callback to progress events triggered in the content recognition Long-Running-Operation (LRO)\n   */\n  onProgress?: (state: RecognizeContentOperationState) => void;\n  /**\n   * A serialized poller which can be used to resume an existing paused Long-Running-Operation.\n   */\n  resumeFrom?: string;\n  /**\n   * Content type of the input. Supported types are \"application/pdf\", \"image/jpeg\", \"image/png\", and \"image/tiff\".\n   */\n  contentType?: FormContentType;\n};\n\n/**\n * The Long-Running-Operation (LRO) poller that allows you to wait until form content is recognized.\n */\nexport type ContentPollerLike = PollerLike<PollOperationState<FormPageArray>, FormPageArray>;\n\n/**\n * Options for retrieving recognized content data\n */\ntype GetRecognizedContentResultOptions = FormRecognizerOperationOptions;\n\n/**\n * Options for recognition of forms\n */\nexport type RecognizeFormsOptions = FormRecognizerOperationOptions & {\n  /**\n   * Specifies whether to include text lines and element references in the result\n   */\n  includeFieldElements?: boolean;\n};\n\n/**\n * The status of a form recognition operation\n */\nexport type RecognizeFormsOperationState = PollOperationState<RecognizedFormArray> & {\n  /**\n   * A string representing the current status of the operation.\n   */\n  status: OperationStatus;\n};\n\n/**\n * Options for starting the analyze form operation\n */\nexport type BeginRecognizeFormsOptions = RecognizeFormsOptions & {\n  /**\n   * Delay to wait until next poll, in milliseconds\n   */\n  updateIntervalInMs?: number;\n  /**\n   * Callback to progress events triggered in the Recognize Form Long-Running-Operation (LRO)\n   */\n  onProgress?: (state: RecognizeFormsOperationState) => void;\n  /**\n   * A serialized poller which can be used to resume an existing paused Long-Running-Operation.\n   */\n  resumeFrom?: string;\n  /**\n   * Content type of the input. Supported types are \"application/pdf\", \"image/jpeg\", \"image/png\", and \"image/tiff\".\n   */\n  contentType?: FormContentType;\n};\n\n/**\n * Result type of the Recognize Form Long-Running-Operation (LRO)\n */\nexport type FormPollerLike = PollerLike<RecognizeFormsOperationState, RecognizedFormArray>;\n\n/**\n * Options for retrieving result of form recognition operation\n */\ntype GetRecognizedFormsOptions = FormRecognizerOperationOptions;\n\n/**\n * Options for retrieving recognized receipt data\n */\ntype GetReceiptsOptions = FormRecognizerOperationOptions;\n\n/**\n * Options for starting the receipt recognition operation\n */\nexport type BeginRecognizeReceiptsOptions = BeginRecognizeFormsOptions;\n\n/**\n * Client class for interacting with Azure Form Recognizer service.\n */\nexport class FormRecognizerClient {\n  /**\n   * Url to an Azure Form Recognizer service endpoint\n   */\n  public readonly endpointUrl: string;\n\n  /**\n   * @internal\n   * @ignore\n   * A reference to the auto-generated FormRecognizer HTTP client.\n   */\n  private readonly client: GeneratedClient;\n\n  /**\n   * Creates an instance of FormRecognizerClient.\n   *\n   * Example usage:\n   * ```ts\n   * import { FormRecognizerClient, AzureKeyCredential } from \"@azure/ai-form-recognizer\";\n   *\n   * const client = new FormRecognizerClient(\n   *    \"<service endpoint>\",\n   *    new AzureKeyCredential(\"<api key>\")\n   * );\n   * ```\n   * @param {string} endpointUrl Url to an Azure Form Recognizer service endpoint\n   * @param {TokenCredential | KeyCredential} credential Used to authenticate requests to the service.\n   * @param {FormRecognizerClientOptions} [options] Used to configure the Form Recognizer client.\n   */\n  constructor(\n    endpointUrl: string,\n    credential: TokenCredential | KeyCredential,\n    options: FormRecognizerClientOptions = {}\n  ) {\n    this.endpointUrl = endpointUrl;\n    const { ...pipelineOptions } = options;\n\n    const libInfo = `azsdk-js-ai-formrecognizer/${SDK_VERSION}`;\n    if (!pipelineOptions.userAgentOptions) {\n      pipelineOptions.userAgentOptions = {};\n    }\n    if (pipelineOptions.userAgentOptions.userAgentPrefix) {\n      pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;\n    } else {\n      pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;\n    }\n\n    const authPolicy = isTokenCredential(credential)\n      ? bearerTokenAuthenticationPolicy(credential, DEFAULT_COGNITIVE_SCOPE)\n      : createFormRecognizerAzureKeyCredentialPolicy(credential);\n\n    const internalPipelineOptions: InternalPipelineOptions = {\n      ...pipelineOptions,\n      ...{\n        loggingOptions: {\n          logger: logger.info,\n          allowedHeaderNames: FormRecognizerLoggingAllowedHeaderNames,\n          allowedQueryParameters: FormRecognizerLoggingAllowedQueryParameters\n        }\n      }\n    };\n\n    const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);\n\n    this.client = new GeneratedClient(this.endpointUrl, pipeline);\n  }\n\n  /**\n   * Recognizes content, including text and table structure from a form document.\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const path = \"./Invoice_7.pdf\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeContent(readStream, \"application/pdf\", {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const pages = await poller.pollUntilDone();\n   * ```\n   * @summary Recognizes content/layout information from a given document\n   * @param {FormRecognizerRequestBody} form Input document\n   * @param {BeginRecognizeContentOptions} [options] Options to start content recognition operation\n   */\n  public async beginRecognizeContent(\n    form: FormRecognizerRequestBody,\n    options: BeginRecognizeContentOptions = {}\n  ): Promise<ContentPollerLike> {\n    const analyzePollerClient: RecognizeContentPollerClient = {\n      beginRecognize: (...args) => recognizeLayoutInternal(this.client, ...args),\n      getRecognizeResult: (...args) => this.getRecognizedContent(...args)\n    };\n\n    const poller = new BeginRecognizeContentPoller({\n      client: analyzePollerClient,\n      source: form,\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes content, including text and table structure from a url to a form document.\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<form document url>\";\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeContentFromUrl(url, {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const pages = await poller.pollUntilDone();\n   * ```\n   * @summary Recognizes content/layout information from a url to a form document\n   * @param {string} formUrl Url to a form document that is accessible from the service. Must be a valid, encoded URL to one of the following supported document types: PDF, JPEG, PNG, and TIFF.\n   * @param {BeginRecognizeContentOptions} [options] Options to start content recognition operation\n   */\n  public async beginRecognizeContentFromUrl(\n    formUrl: string,\n    options: BeginRecognizeContentOptions = {}\n  ): Promise<ContentPollerLike> {\n    const analyzePollerClient: RecognizeContentPollerClient = {\n      beginRecognize: (...args) => recognizeLayoutInternal(this.client, ...args),\n      getRecognizeResult: (...args) => this.getRecognizedContent(...args)\n    };\n\n    if (options.contentType) {\n      logger.warning(\"Ignoring 'contentType' parameter passed to URL-based method.\");\n    }\n\n    const poller = new BeginRecognizeContentPoller({\n      client: analyzePollerClient,\n      source: formUrl,\n      ...options,\n      contentType: undefined\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Retrieves result of content recognition operation.\n   * @private\n   */\n  private async getRecognizedContent(\n    resultId: string,\n    options?: GetRecognizedContentResultOptions\n  ): Promise<RecognizeContentResultResponse> {\n    const realOptions = options || {};\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"FormRecognizerClient-getRecognizedLayoutResult\",\n      realOptions\n    );\n\n    try {\n      const requestOptions = operationOptionsToRequestOptionsBase(finalOptions);\n      const analyzeResult = await this.client.getAnalyzeLayoutResult(resultId, requestOptions);\n      return toRecognizeContentResultResponse(analyzeResult);\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Recognizes forms from a given document using a custom form model from training.\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const path = \"./Invoice_6.pdf\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeCustomForms(modelId, readStream, \"application/pdf\", {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   * const forms = await poller.pollUntilDone();\n   * ```\n   * @summary Recognizes form information from a given document using a custom form model.\n   * @param {string} modelId Id of the custom form model to use\n   * @param {FormRecognizerRequestBody} form Input form document\n   * @param {BeginRecognizeFormsOptions} [options] Options to start the form recognition operation\n   */\n  public async beginRecognizeCustomForms(\n    modelId: string,\n    form: FormRecognizerRequestBody,\n    options: BeginRecognizeFormsOptions = {}\n  ): Promise<FormPollerLike> {\n    if (!modelId) {\n      throw new RangeError(\"Invalid model id\");\n    }\n    const analyzePollerClient: RecognizeCustomFormPollerClient = {\n      beginRecognize: (\n        body: FormRecognizerRequestBody | string,\n        modelId: string,\n        contentType?: FormContentType,\n        analyzeOptions: RecognizeFormsOptions = {}\n      ) => recognizeCustomFormInternal(this.client, body, contentType, analyzeOptions, modelId!),\n      getRecognizeResult: (resultId: string, options: { abortSignal?: AbortSignalLike }) =>\n        this.getRecognizedForm(modelId, resultId, options)\n    };\n\n    const poller = new BeginRecognizeCustomFormPoller({\n      client: analyzePollerClient,\n      modelId,\n      source: form,\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes forms from a url to a form document using a custom form model from training.\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<form document url>\";\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeCustomFormsFromUrl(modelId, url, {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   * const forms = await poller.pollUntilDone();\n   * ```\n   * @summary Recognizes form information from a url to a form document using a custom form model.\n   * @param {string} modelId Id of the custom form model to use\n   * @param {string} formUrl Url to a form document that is accessible from the service. Must be a valid, encoded URL to one of the following supported document types: PDF, JPEG, PNG, and TIFF.\n   * @param {BeginRecognizeFormsOptions} [options] Options to start the form recognition operation\n   */\n  public async beginRecognizeCustomFormsFromUrl(\n    modelId: string,\n    formUrl: string,\n    options: BeginRecognizeFormsOptions = {}\n  ): Promise<FormPollerLike> {\n    if (!modelId) {\n      throw new RangeError(\"Invalid modelId\");\n    }\n    const analyzePollerClient: RecognizeCustomFormPollerClient = {\n      beginRecognize: (\n        body: FormRecognizerRequestBody | string,\n        modelId: string,\n        contentType?: FormContentType,\n        analyzeOptions: RecognizeFormsOptions = {}\n      ) => recognizeCustomFormInternal(this.client, body, contentType, analyzeOptions, modelId!),\n      getRecognizeResult: (resultId: string, options: { abortSignal?: AbortSignalLike }) =>\n        this.getRecognizedForm(modelId, resultId, options)\n    };\n\n    if (options.contentType) {\n      logger.warning(\"Ignoring 'contentType' parameter passed to URL-based method.\");\n    }\n\n    const poller = new BeginRecognizeCustomFormPoller({\n      client: analyzePollerClient,\n      modelId,\n      source: formUrl,\n      ...options,\n      contentType: undefined\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Retrieves result of a form recognition operation.\n   * @private\n   */\n  private async getRecognizedForm(\n    modelId: string,\n    resultId: string,\n    options?: GetRecognizedFormsOptions\n  ): Promise<RecognizeFormResultResponse> {\n    const realOptions = options || {};\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"FormRecognizerClient-getRecognizedForm\",\n      realOptions\n    );\n\n    try {\n      const result = await this.client.getAnalyzeFormResult(\n        modelId,\n        resultId,\n        operationOptionsToRequestOptionsBase(finalOptions)\n      );\n      return toRecognizeFormResultResponse(result);\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Recognizes data from receipts using pre-built receipt model, enabling you to extract structure data\n   * from receipts such as merchant name, merchant phone number, transaction date, and more.\n   *\n   * For a list of fields that are contained in the response, please refer to the \"Supported fields\" section at the following link: https://aka.ms/azsdk/formrecognizer/receiptfields\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const path = \"./contoso-allinone.jpg\";\n   * const readStream = fs.createReadStream(path);\n   *\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeReceipts(readStream, \"image/jpeg\", {\n   *   onProgress: (state) => { console.log(`status: ${state.status}`); }\n   * });\n   *\n   * const receipts = await poller.pollUntilDone();\n   *  if (!receipts || receipts.length <= 0) {\n   *    throw new Error(\"Expecting at lease one receipt in analysis result\");\n   *  }\n   *\n   * const receipt = receipts[0];\n   * console.log(\"First receipt:\");\n   * const receiptTypeField = receipt.fields[\"ReceiptType\"];\n   * if (receiptTypeField.valueType === \"string\") {\n   *   console.log(`  Receipt Type: '${receiptTypeField.value || \"<missing>\"}', with confidence of ${receiptTypeField.confidence}`);\n   * }\n   * const merchantNameField = receipt.fields[\"MerchantName\"];\n   * if (merchantNameField.valueType === \"string\") {\n   *   console.log(`  Merchant Name: '${merchantNameField.value || \"<missing>\"}', with confidence of ${merchantNameField.confidence}`);\n   * }\n   * const transactionDate = receipt.fields[\"TransactionDate\"];\n   * if (transactionDate.valueType === \"date\") {\n   *   console.log(`  Transaction Date: '${transactionDate.value || \"<missing>\"}', with confidence of ${transactionDate.confidence}`);\n   * }\n   * const itemsField = receipt.fields[\"Items\"];\n   * if (itemsField.valueType === \"array\") {\n   *   for (const itemField of itemsField.value || []) {\n   *     if (itemField.valueType === \"object\") {\n   *       const itemNameField = itemField.value![\"Name\"];\n   *       if (itemNameField.valueType === \"string\") {\n   *         console.log(`    Item Name: '${itemNameField.value || \"<missing>\"}', with confidence of ${itemNameField.confidence}`);\n   *       }\n   *     }\n   *  }\n   * }\n   * const totalField = receipt.fields[\"Total\"];\n   * if (totalField.valueType === \"number\") {\n   *   console.log(`  Total: '${totalField.value || \"<missing>\"}', with confidence of ${totalField.confidence}`);\n   * }\n   * ```\n   * @summary Recognizes receipt information from a given document\n   * @param {FormRecognizerRequestBody} receipt Input document\n   * @param {FormContentType} contentType Content type of the input. Supported types are \"application/pdf\", \"image/jpeg\", \"image/png\", and \"image/tiff\";\n   * @param {BeginRecognizeFormsOptions} [options] Options to start the receipt recognition operation\n   */\n  public async beginRecognizeReceipts(\n    receipt: FormRecognizerRequestBody,\n    options: BeginRecognizeReceiptsOptions = {}\n  ): Promise<FormPollerLike> {\n    const analyzePollerClient: RecognizeReceiptPollerClient = {\n      beginRecognize: (...args) => recognizeReceiptInternal(this.client, ...args),\n      getRecognizeResult: (...args) => this.getReceipts(...args)\n    };\n\n    const poller = new BeginRecognizeReceiptPoller({\n      client: analyzePollerClient,\n      source: receipt,\n      ...options\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Recognizes receipt information from a url using pre-built receipt model, enabling you to extract structure data\n   * from receipts such as merchant name, merchant phone number, transaction date, and more.\n   *\n   * For a list of fields that are contained in the response, please refer to the \"Supported fields\" section at the following link: https://aka.ms/azsdk/formrecognizer/receiptfields\n   *\n   * This method returns a long running operation poller that allows you to wait\n   * indefinitely until the operation is completed.\n   * Note that the onProgress callback will not be invoked if the operation completes in the first\n   * request, and attempting to cancel a completed copy will result in an error being thrown.\n   *\n   * Example usage:\n   * ```ts\n   * const url = \"<url to the receipt document>\";\n   * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));\n   * const poller = await client.beginRecognizeReceiptsFromUrl(\n   *   url, {\n   *     includeFieldElements: true,\n   *     onProgress: (state) => { console.log(`analyzing status: ${state.status}`); }\n   * });\n   * const receipts = await poller.pollUntilDone();\n   *  if (!receipts || receipts.length <= 0) {\n   *    throw new Error(\"Expecting at lease one receipt in analysis result\");\n   *  }\n   *\n   * const receipt = receipts[0];\n   * console.log(\"First receipt:\");\n   * const receiptTypeField = receipt.fields[\"ReceiptType\"];\n   * if (receiptTypeField.valueType === \"string\") {\n   *   console.log(`  Receipt Type: '${receiptTypeField.value || \"<missing>\"}', with confidence of ${receiptTypeField.confidence}`);\n   * }\n   * const merchantNameField = receipt.fields[\"MerchantName\"];\n   * if (merchantNameField.valueType === \"string\") {\n   *   console.log(`  Merchant Name: '${merchantNameField.value || \"<missing>\"}', with confidence of ${merchantNameField.confidence}`);\n   * }\n   * const transactionDate = receipt.fields[\"TransactionDate\"];\n   * if (transactionDate.valueType === \"date\") {\n   *   console.log(`  Transaction Date: '${transactionDate.value || \"<missing>\"}', with confidence of ${transactionDate.confidence}`);\n   * }\n   * const itemsField = receipt.fields[\"Items\"];\n   * if (itemsField.valueType === \"array\") {\n   *   for (const itemField of itemsField.value || []) {\n   *     if (itemField.valueType === \"object\") {\n   *       const itemNameField = itemField.value![\"Name\"];\n   *       if (itemNameField.valueType === \"string\") {\n   *         console.log(`    Item Name: '${itemNameField.value || \"<missing>\"}', with confidence of ${itemNameField.confidence}`);\n   *       }\n   *     }\n   *  }\n   * }\n   * const totalField = receipt.fields[\"Total\"];\n   * if (totalField.valueType === \"number\") {\n   *   console.log(`  Total: '${totalField.value || \"<missing>\"}', with confidence of ${totalField.confidence}`);\n   * }\n   * ```\n   * @summary Recognizes receipt information from a given accessible url to input document\n   * @param {string} receiptUrl Url to a receipt document that is accessible from the service. Must be a valid, encoded URL to one of the following supported document types: PDF, JPEG, PNG, and TIFF.\n   * @param {BeginRecognizeFormsOptions} [options] Options to start receipt recognition operation\n   */\n  public async beginRecognizeReceiptsFromUrl(\n    receiptUrl: string,\n    options: BeginRecognizeReceiptsOptions = {}\n  ): Promise<FormPollerLike> {\n    const analyzePollerClient: RecognizeReceiptPollerClient = {\n      beginRecognize: (...args) => recognizeReceiptInternal(this.client, ...args),\n      getRecognizeResult: (...args) => this.getReceipts(...args)\n    };\n\n    if (options.contentType) {\n      logger.warning(\"Ignoring 'contentType' parameter passed to URL-based method.\");\n    }\n\n    const poller = new BeginRecognizeReceiptPoller({\n      client: analyzePollerClient,\n      source: receiptUrl,\n      ...options,\n      contentType: undefined\n    });\n\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Retrieves result of a receipt recognition operation.\n   * @private\n   */\n  private async getReceipts(\n    resultId: string,\n    options?: GetReceiptsOptions\n  ): Promise<RecognizeFormResultResponse> {\n    const realOptions = options || {};\n    const { span, updatedOptions: finalOptions } = createSpan(\n      \"FormRecognizerClient-getRecognizedReceipt\",\n      realOptions\n    );\n\n    try {\n      const result = await this.client.getAnalyzeReceiptResult(\n        resultId,\n        operationOptionsToRequestOptionsBase(finalOptions)\n      );\n      return toRecognizeFormResultResponseFromReceipt(result);\n    } catch (e) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n}\n\n/**\n * @internal\n */\nasync function recognizeLayoutInternal(\n  client: GeneratedClient,\n  body: FormRecognizerRequestBody | string,\n  contentType?: FormContentType,\n  options?: RecognizeContentOptions,\n  _modelId?: string\n): Promise<AnalyzeLayoutAsyncResponseModel> {\n  const realOptions = options || {};\n  const { span, updatedOptions: finalOptions } = createSpan(\"analyzeLayoutInternal\", realOptions);\n  const requestBody = await toRequestBody(body);\n  const requestContentType = contentType ? contentType : await getContentType(requestBody);\n\n  try {\n    if (requestContentType) {\n      return await client.analyzeLayoutAsync(\n        requestContentType,\n        requestBody as Blob | ArrayBuffer | ArrayBufferView,\n        operationOptionsToRequestOptionsBase(finalOptions)\n      );\n    }\n    return await client.analyzeLayoutAsync(\"application/json\", {\n      fileStream: requestBody as SourcePath,\n      ...operationOptionsToRequestOptionsBase(finalOptions)\n    });\n  } catch (e) {\n    span.setStatus({\n      code: CanonicalCode.UNKNOWN,\n      message: e.message\n    });\n    throw e;\n  } finally {\n    span.end();\n  }\n}\n\n/**\n * @internal\n */\nasync function recognizeCustomFormInternal(\n  client: GeneratedClient,\n  body: FormRecognizerRequestBody | string,\n  contentType?: FormContentType,\n  options: RecognizeFormsOptions = {},\n  modelId?: string\n): Promise<AnalyzeWithCustomModelResponseModel> {\n  const { span, updatedOptions: finalOptions } = createSpan(\"analyzeCustomFormInternal\", {\n    ...options,\n    includeTextDetails: options.includeFieldElements\n  });\n  const requestBody = await toRequestBody(body);\n  const requestContentType = contentType ?? (await getContentType(requestBody));\n\n  try {\n    if (requestContentType) {\n      return await client.analyzeWithCustomModel(\n        modelId!,\n        requestContentType,\n        requestBody as Blob | ArrayBuffer | ArrayBufferView,\n        operationOptionsToRequestOptionsBase(finalOptions)\n      );\n    }\n    return await client.analyzeWithCustomModel(modelId!, \"application/json\", {\n      fileStream: requestBody as SourcePath,\n      ...operationOptionsToRequestOptionsBase(finalOptions)\n    });\n  } catch (e) {\n    span.setStatus({\n      code: CanonicalCode.UNKNOWN,\n      message: e.message\n    });\n    throw e;\n  } finally {\n    span.end();\n  }\n}\n\n/**\n * @internal\n */\nasync function recognizeReceiptInternal(\n  client: GeneratedClient,\n  body: FormRecognizerRequestBody | string,\n  contentType?: FormContentType,\n  options?: RecognizeFormsOptions,\n  _modelId?: string\n): Promise<AnalyzeReceiptAsyncResponseModel> {\n  const realOptions = options || { includeFieldElements: false };\n  const { span, updatedOptions: finalOptions } = createSpan(\"analyzeReceiptInternal\", {\n    ...realOptions,\n    includeTextDetails: realOptions.includeFieldElements\n  });\n  const requestBody = await toRequestBody(body);\n  const requestContentType = contentType ?? (await getContentType(requestBody));\n\n  try {\n    if (requestContentType) {\n      return await client.analyzeReceiptAsync(\n        requestContentType,\n        requestBody as Blob | ArrayBuffer | ArrayBufferView,\n        operationOptionsToRequestOptionsBase(finalOptions)\n      );\n    }\n    return await client.analyzeReceiptAsync(\"application/json\", {\n      fileStream: requestBody as SourcePath,\n      ...operationOptionsToRequestOptionsBase(finalOptions)\n    });\n  } catch (e) {\n    span.setStatus({\n      code: CanonicalCode.UNKNOWN,\n      message: e.message\n    });\n    throw e;\n  } finally {\n    span.end();\n  }\n}\n"]}