/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import * as coreHttp from "@azure/core-http";
import * as Parameters from "./models/parameters";
import * as Models from "./models";
import * as Mappers from "./models/mappers";
import { GeneratedClientContext } from "./generatedClientContext";
class GeneratedClient extends GeneratedClientContext {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus2.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        super(endpoint, options);
    }
    /**
     * Create and train a custom model. The request must include a source parameter that is either an
     * externally accessible Azure storage blob container Uri (preferably a Shared Access Signature Uri) or
     * valid path to a data folder in a locally mounted drive. When local paths are specified, they must
     * follow the Linux/Unix path format and be an absolute path rooted to the input mount configuration
     * setting value e.g., if '{Mounts:Input}' configuration setting value is '/input' then a valid source
     * path would be '/input/contosodataset'. All data to be trained is expected to be under the source
     * folder or sub folders under it. Models are trained using documents that are of the following content
     * type - 'application/pdf', 'image/jpeg', 'image/png', 'image/tiff'. Other type of content is ignored.
     * @param trainRequest Training request parameters.
     * @param options The options parameters.
     */
    trainCustomModelAsync(trainRequest, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ trainRequest, options: operationOptions }, trainCustomModelAsyncOperationSpec);
    }
    /**
     * Get detailed information about a custom model.
     * @param modelId Model identifier.
     * @param options The options parameters.
     */
    getCustomModel(modelId, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ modelId, options: operationOptions }, getCustomModelOperationSpec);
    }
    /**
     * Mark model for deletion. Model artifacts will be permanently removed within a predetermined period.
     * @param modelId Model identifier.
     * @param options The options parameters.
     */
    deleteCustomModel(modelId, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ modelId, options: operationOptions }, deleteCustomModelOperationSpec);
    }
    /**
     * Extract key-value pairs, tables, and semantic values from a given document. The input document must
     * be of one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or
     * 'image/tiff'. Alternatively, use 'application/json' type to specify the location (Uri or local path)
     * of the document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeWithCustomModel(...args) {
        let operationSpec;
        let operationArguments;
        if (args[1] === "application/pdf" ||
            args[1] === "image/jpeg" ||
            args[1] === "image/png" ||
            args[1] === "image/tiff") {
            operationSpec = analyzeWithCustomModel$binaryOperationSpec;
            operationArguments = {
                modelId: args[0],
                contentType: args[1],
                fileStream: args[2],
                options: args[3]
            };
        }
        else if (args[1] === "application/json") {
            operationSpec = analyzeWithCustomModel$jsonOperationSpec;
            operationArguments = {
                modelId: args[0],
                contentType: args[1],
                options: args[2]
            };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[1]}".`);
        }
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Obtain current status and the result of the analyze form operation.
     * @param modelId Model identifier.
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeFormResult(modelId, resultId, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ modelId, resultId, options: operationOptions }, getAnalyzeFormResultOperationSpec);
    }
    /**
     * Copy custom model stored in this resource (the source) to user specified target Form Recognizer
     * resource.
     * @param modelId Model identifier.
     * @param copyRequest Copy request parameters.
     * @param options The options parameters.
     */
    copyCustomModel(modelId, copyRequest, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ modelId, copyRequest, options: operationOptions }, copyCustomModelOperationSpec);
    }
    /**
     * Obtain current status and the result of a custom model copy operation.
     * @param modelId Model identifier.
     * @param resultId Copy operation result identifier.
     * @param options The options parameters.
     */
    getCustomModelCopyResult(modelId, resultId, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ modelId, resultId, options: operationOptions }, getCustomModelCopyResultOperationSpec);
    }
    /**
     * Generate authorization to copy a model into the target Form Recognizer resource.
     * @param options The options parameters.
     */
    generateModelCopyAuthorization(options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ options: operationOptions }, generateModelCopyAuthorizationOperationSpec);
    }
    /**
     * Extract field text and semantic values from a given receipt document. The input document must be of
     * one of the supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the
     * document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeReceiptAsync(...args) {
        let operationSpec;
        let operationArguments;
        if (args[0] === "application/pdf" ||
            args[0] === "image/jpeg" ||
            args[0] === "image/png" ||
            args[0] === "image/tiff") {
            operationSpec = analyzeReceiptAsync$binaryOperationSpec;
            operationArguments = {
                contentType: args[0],
                fileStream: args[1],
                options: args[2]
            };
        }
        else if (args[0] === "application/json") {
            operationSpec = analyzeReceiptAsync$jsonOperationSpec;
            operationArguments = {
                contentType: args[0],
                options: args[1]
            };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[0]}".`);
        }
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Track the progress and obtain the result of the analyze receipt operation.
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeReceiptResult(resultId, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ resultId, options: operationOptions }, getAnalyzeReceiptResultOperationSpec);
    }
    /**
     * Extract text and layout information from a given document. The input document must be of one of the
     * supported content types - 'application/pdf', 'image/jpeg', 'image/png' or 'image/tiff'.
     * Alternatively, use 'application/json' type to specify the location (Uri or local path) of the
     * document to be analyzed.
     * @param args Includes all the parameters for this operation.
     */
    analyzeLayoutAsync(...args) {
        let operationSpec;
        let operationArguments;
        if (args[0] === "application/pdf" ||
            args[0] === "image/jpeg" ||
            args[0] === "image/png" ||
            args[0] === "image/tiff") {
            operationSpec = analyzeLayoutAsync$binaryOperationSpec;
            operationArguments = {
                contentType: args[0],
                fileStream: args[1],
                options: args[2]
            };
        }
        else if (args[0] === "application/json") {
            operationSpec = analyzeLayoutAsync$jsonOperationSpec;
            operationArguments = {
                contentType: args[0],
                options: args[1]
            };
        }
        else {
            throw new TypeError(`"contentType" must be a valid value but instead was "${args[0]}".`);
        }
        return this.sendOperationRequest(operationArguments, operationSpec);
    }
    /**
     * Track the progress and obtain the result of the analyze layout operation
     * @param resultId Analyze operation result identifier.
     * @param options The options parameters.
     */
    getAnalyzeLayoutResult(resultId, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ resultId, options: operationOptions }, getAnalyzeLayoutResultOperationSpec);
    }
    /**
     * Get information about all custom models
     * @param options The options parameters.
     */
    listCustomModels(options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ options: operationOptions }, listCustomModelsOperationSpec);
    }
    /**
     * Get information about all custom models
     * @param options The options parameters.
     */
    getCustomModels(options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ options: operationOptions }, getCustomModelsOperationSpec);
    }
    /**
     * ListCustomModelsNext
     * @param nextLink The nextLink from the previous successful call to the ListCustomModels method.
     * @param options The options parameters.
     */
    listCustomModelsNext(nextLink, options) {
        const operationOptions = coreHttp.operationOptionsToRequestOptionsBase(options || {});
        return this.sendOperationRequest({ nextLink, options: operationOptions }, listCustomModelsNextOperationSpec);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);
const trainCustomModelAsyncOperationSpec = {
    path: "/custom/models",
    httpMethod: "POST",
    responses: {
        201: {
            headersMapper: Mappers.GeneratedClientTrainCustomModelAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.trainRequest,
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.contentType],
    mediaType: "json",
    serializer
};
const getCustomModelOperationSpec = {
    path: "/custom/models/{modelId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.Model
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.includeKeys],
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    serializer
};
const deleteCustomModelOperationSpec = {
    path: "/custom/models/{modelId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    serializer
};
const analyzeWithCustomModel$binaryOperationSpec = {
    path: "/custom/models/{modelId}/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeWithCustomModelHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream,
    queryParameters: [Parameters.includeTextDetails],
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    headerParameters: [Parameters.contentType1],
    mediaType: "binary",
    serializer
};
const analyzeWithCustomModel$jsonOperationSpec = {
    path: "/custom/models/{modelId}/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeWithCustomModelHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream1,
    queryParameters: [Parameters.includeTextDetails],
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    headerParameters: [Parameters.contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeFormResultOperationSpec = {
    path: "/custom/models/{modelId}/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.AnalyzeOperationResult
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint, Parameters.modelId, Parameters.resultId],
    serializer
};
const copyCustomModelOperationSpec = {
    path: "/custom/models/{modelId}/copy",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientCopyCustomModelHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.copyRequest,
    urlParameters: [Parameters.endpoint, Parameters.modelId],
    headerParameters: [Parameters.contentType],
    mediaType: "json",
    serializer
};
const getCustomModelCopyResultOperationSpec = {
    path: "/custom/models/{modelId}/copyResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.CopyOperationResult
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint, Parameters.modelId, Parameters.resultId],
    serializer
};
const generateModelCopyAuthorizationOperationSpec = {
    path: "/custom/models/copyAuthorization",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: Mappers.CopyAuthorizationResult,
            headersMapper: Mappers.GeneratedClientGenerateModelCopyAuthorizationHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint],
    serializer
};
const analyzeReceiptAsync$binaryOperationSpec = {
    path: "/prebuilt/receipt/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeReceiptAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream,
    queryParameters: [Parameters.includeTextDetails],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.contentType1],
    mediaType: "binary",
    serializer
};
const analyzeReceiptAsync$jsonOperationSpec = {
    path: "/prebuilt/receipt/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeReceiptAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream1,
    queryParameters: [Parameters.includeTextDetails],
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeReceiptResultOperationSpec = {
    path: "/prebuilt/receipt/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.AnalyzeOperationResult
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint, Parameters.resultId],
    serializer
};
const analyzeLayoutAsync$binaryOperationSpec = {
    path: "/layout/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeLayoutAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream,
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.contentType1],
    mediaType: "binary",
    serializer
};
const analyzeLayoutAsync$jsonOperationSpec = {
    path: "/layout/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: Mappers.GeneratedClientAnalyzeLayoutAsyncHeaders
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.fileStream1,
    urlParameters: [Parameters.endpoint],
    headerParameters: [Parameters.contentType2],
    mediaType: "json",
    serializer
};
const getAnalyzeLayoutResultOperationSpec = {
    path: "/layout/analyzeResults/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.AnalyzeOperationResult
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [Parameters.endpoint, Parameters.resultId],
    serializer
};
const listCustomModelsOperationSpec = {
    path: "/custom/models",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.Models
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.op],
    urlParameters: [Parameters.endpoint],
    serializer
};
const getCustomModelsOperationSpec = {
    path: "/custom/models",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.Models
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.op1],
    urlParameters: [Parameters.endpoint],
    serializer
};
const listCustomModelsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.Models
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.op],
    urlParameters: [Parameters.endpoint, Parameters.nextLink],
    serializer
};
// Operation Specifications
export { GeneratedClient, GeneratedClientContext, Models as GeneratedModels, Mappers as GeneratedMappers };
//# sourceMappingURL=generatedClient.js.map