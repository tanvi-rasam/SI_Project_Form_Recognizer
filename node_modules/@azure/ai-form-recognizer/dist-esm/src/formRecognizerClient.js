// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter, __rest } from "tslib";
import { createPipelineFromOptions, isTokenCredential, bearerTokenAuthenticationPolicy, operationOptionsToRequestOptionsBase } from "@azure/core-http";
import { SDK_VERSION, DEFAULT_COGNITIVE_SCOPE, FormRecognizerLoggingAllowedHeaderNames, FormRecognizerLoggingAllowedQueryParameters } from "./constants";
import { logger } from "./logger";
import { createSpan } from "./tracing";
import { toRequestBody, getContentType } from "./common";
import { CanonicalCode } from "@opentelemetry/api";
import { GeneratedClient } from "./generated/generatedClient";
import { BeginRecognizeContentPoller } from "./lro/analyze/contentPoller";
import { BeginRecognizeCustomFormPoller } from "./lro/analyze/customFormPoller";
import { BeginRecognizeReceiptPoller } from "./lro/analyze/receiptPoller";
import { toRecognizeFormResultResponse, toRecognizeContentResultResponse, toRecognizeFormResultResponseFromReceipt } from "./transforms";
import { createFormRecognizerAzureKeyCredentialPolicy } from "./azureKeyCredentialPolicy";
/**
 * Client class for interacting with Azure Form Recognizer service.
 */
export class FormRecognizerClient {
    /**
     * Creates an instance of FormRecognizerClient.
     *
     * Example usage:
     * ```ts
     * import { FormRecognizerClient, AzureKeyCredential } from "@azure/ai-form-recognizer";
     *
     * const client = new FormRecognizerClient(
     *    "<service endpoint>",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     * @param {string} endpointUrl Url to an Azure Form Recognizer service endpoint
     * @param {TokenCredential | KeyCredential} credential Used to authenticate requests to the service.
     * @param {FormRecognizerClientOptions} [options] Used to configure the Form Recognizer client.
     */
    constructor(endpointUrl, credential, options = {}) {
        this.endpointUrl = endpointUrl;
        const pipelineOptions = __rest(options, []);
        const libInfo = `azsdk-js-ai-formrecognizer/${SDK_VERSION}`;
        if (!pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions = {};
        }
        if (pipelineOptions.userAgentOptions.userAgentPrefix) {
            pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;
        }
        const authPolicy = isTokenCredential(credential)
            ? bearerTokenAuthenticationPolicy(credential, DEFAULT_COGNITIVE_SCOPE)
            : createFormRecognizerAzureKeyCredentialPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: FormRecognizerLoggingAllowedHeaderNames,
                allowedQueryParameters: FormRecognizerLoggingAllowedQueryParameters
            }
        });
        const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new GeneratedClient(this.endpointUrl, pipeline);
    }
    /**
     * Recognizes content, including text and table structure from a form document.
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./Invoice_7.pdf";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeContent(readStream, "application/pdf", {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const pages = await poller.pollUntilDone();
     * ```
     * @summary Recognizes content/layout information from a given document
     * @param {FormRecognizerRequestBody} form Input document
     * @param {BeginRecognizeContentOptions} [options] Options to start content recognition operation
     */
    beginRecognizeContent(form, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const analyzePollerClient = {
                beginRecognize: (...args) => recognizeLayoutInternal(this.client, ...args),
                getRecognizeResult: (...args) => this.getRecognizedContent(...args)
            };
            const poller = new BeginRecognizeContentPoller(Object.assign({ client: analyzePollerClient, source: form }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes content, including text and table structure from a url to a form document.
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<form document url>";
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeContentFromUrl(url, {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const pages = await poller.pollUntilDone();
     * ```
     * @summary Recognizes content/layout information from a url to a form document
     * @param {string} formUrl Url to a form document that is accessible from the service. Must be a valid, encoded URL to one of the following supported document types: PDF, JPEG, PNG, and TIFF.
     * @param {BeginRecognizeContentOptions} [options] Options to start content recognition operation
     */
    beginRecognizeContentFromUrl(formUrl, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const analyzePollerClient = {
                beginRecognize: (...args) => recognizeLayoutInternal(this.client, ...args),
                getRecognizeResult: (...args) => this.getRecognizedContent(...args)
            };
            if (options.contentType) {
                logger.warning("Ignoring 'contentType' parameter passed to URL-based method.");
            }
            const poller = new BeginRecognizeContentPoller(Object.assign(Object.assign({ client: analyzePollerClient, source: formUrl }, options), { contentType: undefined }));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Retrieves result of content recognition operation.
     * @private
     */
    getRecognizedContent(resultId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const realOptions = options || {};
            const { span, updatedOptions: finalOptions } = createSpan("FormRecognizerClient-getRecognizedLayoutResult", realOptions);
            try {
                const requestOptions = operationOptionsToRequestOptionsBase(finalOptions);
                const analyzeResult = yield this.client.getAnalyzeLayoutResult(resultId, requestOptions);
                return toRecognizeContentResultResponse(analyzeResult);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Recognizes forms from a given document using a custom form model from training.
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./Invoice_6.pdf";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeCustomForms(modelId, readStream, "application/pdf", {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     * const forms = await poller.pollUntilDone();
     * ```
     * @summary Recognizes form information from a given document using a custom form model.
     * @param {string} modelId Id of the custom form model to use
     * @param {FormRecognizerRequestBody} form Input form document
     * @param {BeginRecognizeFormsOptions} [options] Options to start the form recognition operation
     */
    beginRecognizeCustomForms(modelId, form, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!modelId) {
                throw new RangeError("Invalid model id");
            }
            const analyzePollerClient = {
                beginRecognize: (body, modelId, contentType, analyzeOptions = {}) => recognizeCustomFormInternal(this.client, body, contentType, analyzeOptions, modelId),
                getRecognizeResult: (resultId, options) => this.getRecognizedForm(modelId, resultId, options)
            };
            const poller = new BeginRecognizeCustomFormPoller(Object.assign({ client: analyzePollerClient, modelId, source: form }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes forms from a url to a form document using a custom form model from training.
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<form document url>";
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeCustomFormsFromUrl(modelId, url, {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     * const forms = await poller.pollUntilDone();
     * ```
     * @summary Recognizes form information from a url to a form document using a custom form model.
     * @param {string} modelId Id of the custom form model to use
     * @param {string} formUrl Url to a form document that is accessible from the service. Must be a valid, encoded URL to one of the following supported document types: PDF, JPEG, PNG, and TIFF.
     * @param {BeginRecognizeFormsOptions} [options] Options to start the form recognition operation
     */
    beginRecognizeCustomFormsFromUrl(modelId, formUrl, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!modelId) {
                throw new RangeError("Invalid modelId");
            }
            const analyzePollerClient = {
                beginRecognize: (body, modelId, contentType, analyzeOptions = {}) => recognizeCustomFormInternal(this.client, body, contentType, analyzeOptions, modelId),
                getRecognizeResult: (resultId, options) => this.getRecognizedForm(modelId, resultId, options)
            };
            if (options.contentType) {
                logger.warning("Ignoring 'contentType' parameter passed to URL-based method.");
            }
            const poller = new BeginRecognizeCustomFormPoller(Object.assign(Object.assign({ client: analyzePollerClient, modelId, source: formUrl }, options), { contentType: undefined }));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Retrieves result of a form recognition operation.
     * @private
     */
    getRecognizedForm(modelId, resultId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const realOptions = options || {};
            const { span, updatedOptions: finalOptions } = createSpan("FormRecognizerClient-getRecognizedForm", realOptions);
            try {
                const result = yield this.client.getAnalyzeFormResult(modelId, resultId, operationOptionsToRequestOptionsBase(finalOptions));
                return toRecognizeFormResultResponse(result);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Recognizes data from receipts using pre-built receipt model, enabling you to extract structure data
     * from receipts such as merchant name, merchant phone number, transaction date, and more.
     *
     * For a list of fields that are contained in the response, please refer to the "Supported fields" section at the following link: https://aka.ms/azsdk/formrecognizer/receiptfields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const path = "./contoso-allinone.jpg";
     * const readStream = fs.createReadStream(path);
     *
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeReceipts(readStream, "image/jpeg", {
     *   onProgress: (state) => { console.log(`status: ${state.status}`); }
     * });
     *
     * const receipts = await poller.pollUntilDone();
     *  if (!receipts || receipts.length <= 0) {
     *    throw new Error("Expecting at lease one receipt in analysis result");
     *  }
     *
     * const receipt = receipts[0];
     * console.log("First receipt:");
     * const receiptTypeField = receipt.fields["ReceiptType"];
     * if (receiptTypeField.valueType === "string") {
     *   console.log(`  Receipt Type: '${receiptTypeField.value || "<missing>"}', with confidence of ${receiptTypeField.confidence}`);
     * }
     * const merchantNameField = receipt.fields["MerchantName"];
     * if (merchantNameField.valueType === "string") {
     *   console.log(`  Merchant Name: '${merchantNameField.value || "<missing>"}', with confidence of ${merchantNameField.confidence}`);
     * }
     * const transactionDate = receipt.fields["TransactionDate"];
     * if (transactionDate.valueType === "date") {
     *   console.log(`  Transaction Date: '${transactionDate.value || "<missing>"}', with confidence of ${transactionDate.confidence}`);
     * }
     * const itemsField = receipt.fields["Items"];
     * if (itemsField.valueType === "array") {
     *   for (const itemField of itemsField.value || []) {
     *     if (itemField.valueType === "object") {
     *       const itemNameField = itemField.value!["Name"];
     *       if (itemNameField.valueType === "string") {
     *         console.log(`    Item Name: '${itemNameField.value || "<missing>"}', with confidence of ${itemNameField.confidence}`);
     *       }
     *     }
     *  }
     * }
     * const totalField = receipt.fields["Total"];
     * if (totalField.valueType === "number") {
     *   console.log(`  Total: '${totalField.value || "<missing>"}', with confidence of ${totalField.confidence}`);
     * }
     * ```
     * @summary Recognizes receipt information from a given document
     * @param {FormRecognizerRequestBody} receipt Input document
     * @param {FormContentType} contentType Content type of the input. Supported types are "application/pdf", "image/jpeg", "image/png", and "image/tiff";
     * @param {BeginRecognizeFormsOptions} [options] Options to start the receipt recognition operation
     */
    beginRecognizeReceipts(receipt, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const analyzePollerClient = {
                beginRecognize: (...args) => recognizeReceiptInternal(this.client, ...args),
                getRecognizeResult: (...args) => this.getReceipts(...args)
            };
            const poller = new BeginRecognizeReceiptPoller(Object.assign({ client: analyzePollerClient, source: receipt }, options));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Recognizes receipt information from a url using pre-built receipt model, enabling you to extract structure data
     * from receipts such as merchant name, merchant phone number, transaction date, and more.
     *
     * For a list of fields that are contained in the response, please refer to the "Supported fields" section at the following link: https://aka.ms/azsdk/formrecognizer/receiptfields
     *
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the operation is completed.
     * Note that the onProgress callback will not be invoked if the operation completes in the first
     * request, and attempting to cancel a completed copy will result in an error being thrown.
     *
     * Example usage:
     * ```ts
     * const url = "<url to the receipt document>";
     * const client = new FormRecognizerClient(endpoint, new AzureKeyCredential(apiKey));
     * const poller = await client.beginRecognizeReceiptsFromUrl(
     *   url, {
     *     includeFieldElements: true,
     *     onProgress: (state) => { console.log(`analyzing status: ${state.status}`); }
     * });
     * const receipts = await poller.pollUntilDone();
     *  if (!receipts || receipts.length <= 0) {
     *    throw new Error("Expecting at lease one receipt in analysis result");
     *  }
     *
     * const receipt = receipts[0];
     * console.log("First receipt:");
     * const receiptTypeField = receipt.fields["ReceiptType"];
     * if (receiptTypeField.valueType === "string") {
     *   console.log(`  Receipt Type: '${receiptTypeField.value || "<missing>"}', with confidence of ${receiptTypeField.confidence}`);
     * }
     * const merchantNameField = receipt.fields["MerchantName"];
     * if (merchantNameField.valueType === "string") {
     *   console.log(`  Merchant Name: '${merchantNameField.value || "<missing>"}', with confidence of ${merchantNameField.confidence}`);
     * }
     * const transactionDate = receipt.fields["TransactionDate"];
     * if (transactionDate.valueType === "date") {
     *   console.log(`  Transaction Date: '${transactionDate.value || "<missing>"}', with confidence of ${transactionDate.confidence}`);
     * }
     * const itemsField = receipt.fields["Items"];
     * if (itemsField.valueType === "array") {
     *   for (const itemField of itemsField.value || []) {
     *     if (itemField.valueType === "object") {
     *       const itemNameField = itemField.value!["Name"];
     *       if (itemNameField.valueType === "string") {
     *         console.log(`    Item Name: '${itemNameField.value || "<missing>"}', with confidence of ${itemNameField.confidence}`);
     *       }
     *     }
     *  }
     * }
     * const totalField = receipt.fields["Total"];
     * if (totalField.valueType === "number") {
     *   console.log(`  Total: '${totalField.value || "<missing>"}', with confidence of ${totalField.confidence}`);
     * }
     * ```
     * @summary Recognizes receipt information from a given accessible url to input document
     * @param {string} receiptUrl Url to a receipt document that is accessible from the service. Must be a valid, encoded URL to one of the following supported document types: PDF, JPEG, PNG, and TIFF.
     * @param {BeginRecognizeFormsOptions} [options] Options to start receipt recognition operation
     */
    beginRecognizeReceiptsFromUrl(receiptUrl, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const analyzePollerClient = {
                beginRecognize: (...args) => recognizeReceiptInternal(this.client, ...args),
                getRecognizeResult: (...args) => this.getReceipts(...args)
            };
            if (options.contentType) {
                logger.warning("Ignoring 'contentType' parameter passed to URL-based method.");
            }
            const poller = new BeginRecognizeReceiptPoller(Object.assign(Object.assign({ client: analyzePollerClient, source: receiptUrl }, options), { contentType: undefined }));
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Retrieves result of a receipt recognition operation.
     * @private
     */
    getReceipts(resultId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const realOptions = options || {};
            const { span, updatedOptions: finalOptions } = createSpan("FormRecognizerClient-getRecognizedReceipt", realOptions);
            try {
                const result = yield this.client.getAnalyzeReceiptResult(resultId, operationOptionsToRequestOptionsBase(finalOptions));
                return toRecognizeFormResultResponseFromReceipt(result);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
}
/**
 * @internal
 */
function recognizeLayoutInternal(client, body, contentType, options, _modelId) {
    return __awaiter(this, void 0, void 0, function* () {
        const realOptions = options || {};
        const { span, updatedOptions: finalOptions } = createSpan("analyzeLayoutInternal", realOptions);
        const requestBody = yield toRequestBody(body);
        const requestContentType = contentType ? contentType : yield getContentType(requestBody);
        try {
            if (requestContentType) {
                return yield client.analyzeLayoutAsync(requestContentType, requestBody, operationOptionsToRequestOptionsBase(finalOptions));
            }
            return yield client.analyzeLayoutAsync("application/json", Object.assign({ fileStream: requestBody }, operationOptionsToRequestOptionsBase(finalOptions)));
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    });
}
/**
 * @internal
 */
function recognizeCustomFormInternal(client, body, contentType, options = {}, modelId) {
    return __awaiter(this, void 0, void 0, function* () {
        const { span, updatedOptions: finalOptions } = createSpan("analyzeCustomFormInternal", Object.assign(Object.assign({}, options), { includeTextDetails: options.includeFieldElements }));
        const requestBody = yield toRequestBody(body);
        const requestContentType = contentType !== null && contentType !== void 0 ? contentType : (yield getContentType(requestBody));
        try {
            if (requestContentType) {
                return yield client.analyzeWithCustomModel(modelId, requestContentType, requestBody, operationOptionsToRequestOptionsBase(finalOptions));
            }
            return yield client.analyzeWithCustomModel(modelId, "application/json", Object.assign({ fileStream: requestBody }, operationOptionsToRequestOptionsBase(finalOptions)));
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    });
}
/**
 * @internal
 */
function recognizeReceiptInternal(client, body, contentType, options, _modelId) {
    return __awaiter(this, void 0, void 0, function* () {
        const realOptions = options || { includeFieldElements: false };
        const { span, updatedOptions: finalOptions } = createSpan("analyzeReceiptInternal", Object.assign(Object.assign({}, realOptions), { includeTextDetails: realOptions.includeFieldElements }));
        const requestBody = yield toRequestBody(body);
        const requestContentType = contentType !== null && contentType !== void 0 ? contentType : (yield getContentType(requestBody));
        try {
            if (requestContentType) {
                return yield client.analyzeReceiptAsync(requestContentType, requestBody, operationOptionsToRequestOptionsBase(finalOptions));
            }
            return yield client.analyzeReceiptAsync("application/json", Object.assign({ fileStream: requestBody }, operationOptionsToRequestOptionsBase(finalOptions)));
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    });
}
//# sourceMappingURL=formRecognizerClient.js.map