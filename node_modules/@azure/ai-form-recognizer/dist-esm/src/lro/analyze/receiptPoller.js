// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter } from "tslib";
import { delay } from "@azure/core-http";
import { Poller } from "@azure/core-lro";
/**
 * Class that represents a poller that waits until a model has been trained.
 */
export class BeginRecognizeReceiptPoller extends Poller {
    constructor(options) {
        const { client, source, contentType, updateIntervalInMs = 5000, resultId, onProgress, resumeFrom } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = makeBeginRecognizePollOperation(Object.assign(Object.assign({}, state), { client,
            source,
            contentType,
            resultId, status: "notStarted", analyzeOptions: options }));
        super(operation);
        if (typeof onProgress === "function") {
            this.onProgress(onProgress);
        }
        this.updateIntervalInMs = updateIntervalInMs;
    }
    delay() {
        return delay(this.updateIntervalInMs);
    }
}
/**
 * Creates a poll operation given the provided state.
 * @ignore
 */
function makeBeginRecognizePollOperation(state) {
    return {
        state: Object.assign({}, state),
        cancel(_options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                throw new Error("Cancel operation is not supported.");
            });
        },
        update(options = {}) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const state = this.state;
                const { client, source, contentType, analyzeOptions } = state;
                if (!state.isStarted) {
                    if (!source) {
                        throw new Error("Expect a valid 'source'");
                    }
                    state.isStarted = true;
                    const result = yield client.beginRecognize(source, contentType, analyzeOptions || {});
                    if (!result.operationLocation) {
                        throw new Error("Expect a valid 'operationLocation' to retrieve analyze results");
                    }
                    const lastSlashIndex = result.operationLocation.lastIndexOf("/");
                    state.resultId = result.operationLocation.substring(lastSlashIndex + 1);
                    // source is no longer needed
                    state.source = undefined;
                }
                const response = yield client.getRecognizeResult(state.resultId, {
                    abortSignal: analyzeOptions === null || analyzeOptions === void 0 ? void 0 : analyzeOptions.abortSignal
                });
                state.status = response.status;
                if (!state.isCompleted) {
                    if (typeof options.fireProgress === "function") {
                        options.fireProgress(state);
                    }
                    if (response.status === "succeeded") {
                        state.result = response.forms;
                        state.isCompleted = true;
                    }
                    else if (response.status === "failed") {
                        const errors = (_a = response.errors) === null || _a === void 0 ? void 0 : _a.map((e) => `  code ${e.code}, message: '${e.message}'`).join("\n");
                        const message = `Receipt recognition failed.
Error(s):
${errors || ""}
`;
                        throw new Error(message);
                    }
                }
                return makeBeginRecognizePollOperation(state);
            });
        },
        toString() {
            return JSON.stringify({ state: this.state }, (key, value) => {
                if (key === "client" || key === "source") {
                    return undefined;
                }
                return value;
            });
        }
    };
}
//# sourceMappingURL=receiptPoller.js.map