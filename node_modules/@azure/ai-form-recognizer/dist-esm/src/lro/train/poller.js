// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __awaiter } from "tslib";
import { delay } from "@azure/core-http";
import { Poller } from "@azure/core-lro";
/**
 * Class that represents a poller that waits until a model has been trained.
 */
export class BeginTrainingPoller extends Poller {
    constructor(options) {
        const { client, source, updateIntervalInMs = 5000, onProgress, resumeFrom, trainModelOptions } = options;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = makeBeginTrainingPollOperation(Object.assign(Object.assign({}, state), { client,
            source, status: "creating", trainModelOptions }));
        super(operation);
        if (typeof onProgress === "function") {
            this.onProgress(onProgress);
        }
        this.updateIntervalInMs = updateIntervalInMs;
    }
    delay() {
        return delay(this.updateIntervalInMs);
    }
}
/**
 * Creates a poll operation given the provided state.
 * @ignore
 */
function makeBeginTrainingPollOperation(state) {
    return {
        state: Object.assign({}, state),
        cancel(_options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                throw new Error("Cancel operation is not supported.");
            });
        },
        update(options = {}) {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function* () {
                const state = this.state;
                const { client, source, trainModelOptions } = state;
                if (!state.isStarted) {
                    state.isStarted = true;
                    const result = yield client.trainCustomModelInternal(source, false, trainModelOptions || {});
                    if (!result.location) {
                        throw new Error("Expect a valid 'operationLocation' to retrieve analyze results");
                    }
                    const lastSlashIndex = result.location.lastIndexOf("/");
                    state.modelId = result.location.substring(lastSlashIndex + 1);
                }
                const model = yield client.getCustomModel(state.modelId, {
                    abortSignal: trainModelOptions === null || trainModelOptions === void 0 ? void 0 : trainModelOptions.abortSignal
                });
                state.status = model.status;
                if (!state.isCompleted) {
                    if (typeof options.fireProgress === "function") {
                        options.fireProgress(state);
                    }
                    if (model.status === "ready") {
                        state.result = model;
                        state.isCompleted = true;
                    }
                    else if (model.status === "invalid") {
                        const errors = (_a = model.errors) === null || _a === void 0 ? void 0 : _a.map((e) => `  code ${e.code}, message: '${e.message}'`).join("\n");
                        const additionalInfo = (_b = model.trainingDocuments) === null || _b === void 0 ? void 0 : _b.map((d) => {
                            var _a;
                            return `  document: ${d.name}, status: ${d.status}, errors: ${(_a = d.errors) === null || _a === void 0 ? void 0 : _a.map((e) => `code ${e.code}, message: '${e.message}'`).join("\n")}`;
                        }).join("\n");
                        const message = `Model training failed. Invalid model was created with id '${state.modelId}'.
Error(s):
${errors || ""}
Additional information:
${additionalInfo || ""}
`;
                        throw new Error(message);
                    }
                }
                return makeBeginTrainingPollOperation(state);
            });
        },
        toString() {
            return JSON.stringify({ state: this.state }, (key, value) => {
                if (key === "client") {
                    return undefined;
                }
                return value;
            });
        }
    };
}
//# sourceMappingURL=poller.js.map